---
title: "2.10 Mechanism: Address Translation"
order: "11"
---
[[Study Log/os_study/0_ostep_index|Return to Index]]

## 2.10 Mechanism: Address Translation

在CPU的虚拟化中，我们介绍了LDE。在绝大多数情况下，让程序**直接**运行在硬件上，然而在一些关键点，比如程序发起了一个系统调用，或者一个时钟中断产生，安排操作系统入场，让正确的事情发生。就是这些时机，让操作系统能更好地控制程序，利用物理硬件。

其中一个OS要做的事情，就是内存虚拟化。

> [!question] 本章的问题：
> 1. 如何构建一个高效率的内存虚拟化？
> 2. 如何让程序用着方便灵活？
> 3. 如何控制程序能访问的内存，保证程序对内存的访问是受到限制的？
> 4. 如何让以上行为变得高效？

- [ ] #TODO tasktodo1746030134256 之前每章的CRUX要补一下，看看问题是否都能回答 ➕ 2025-05-01 🔺 🆔 cpraus 

我们要介绍的高科技是啥呢？标题写了，就叫地址翻译（Hardware-based Address Translation）。**硬件**会把每个指令的虚拟地址翻译成物理地址。

当然，也不能只靠硬件翻译。OS在特定的时机也要上场，追踪内存的使用情况才行。 ^344dcc

现在我们来总结一下：程序有自己的私有内存，存放自己的数据和代码。在这背后是丑陋的物理层真相：程序们其实在共享同一片内存空间，CPU运行一个程序，然后运行下一个。通过虚拟化，操作系统在硬件的帮助下，可以把这个丑陋的真相做一个有用的、强大的、易用的抽象。

### 2.10.1 Assumptions

我们一开始做的假设很简单，甚至让你感觉可笑。别急，后面就是操作系统笑话你了：

1. 假设用户的地址空间在物理内存中必须是连续的；
2. 地址空间不能太大，比物理空间要小；
3. 每一个（程序的）地址空间需要是同样的大小。

### 2.10.2 An Example

下面这段代码：

```c
voic func() {
	int x = 3000;
	x = x + 3;
}
```

编译器把代码变成汇编，如果是x86汇编，就像下面这样：

```asm
128: movl 0x0(%ebx), %eax   ;load 0+ebx into eax 
132: addl $0x03, %eax       ;add 3 to eax register 
135: movl %eax, 0x0(%ebx)   ;store eax back to mem
```

上面三行是`x = x + 3`的汇编。x的地址现在在ebx寄存器，然后把这里面的值放到通用寄存器eax中，使用movl指令（用来移动longword）。下一行就是把eax的值增加3。最后一行是把eax中的值加载回ebx中，也就是回到内存（注意，这里是加载到ebx的地址上，所以是内存地址里，并不是放到ebx寄存器上。这个寄存器存的是地址不是值）。

- [ ] #TODO tasktodo1746033660626 有时间自己把这个汇编生成一下。 ➕ 2025-05-01 🔽 🆔 0zxcta 

在上面的例子中，内存情况如下：

![[Study Log/os_study/2_virtualization/resources/Pasted image 20250501010725.png|200]]

代码存在Program Code，从128地址开始（离0地址很近）。而变量x的值是3000,存在地址15KB。

当这些指令执行时，在进程的视角，会发生下面的事情：

1. 取128地址的指令；
2. 执行这个指令（从15KB地址读取一个值）;
3. 取132地址的指令；
4. 执行这个指令（没有内存访问）;
5. 取135地址的指令；
6. 执行这个指令（把值存到15KB地址）。

在进程的视角上，地址空间从0开始，到16KB。但是为了内存虚拟化，操作系统要把这些地址放到物理内存中。因此，问题出现了：怎么把这些地址重新编排，使得对于进程来说是**透明**的？下面是一个例子：

![[Study Log/os_study/2_virtualization/resources/Pasted image 20250501195207.png|200]]

上面这个是物理内存的一种情况。0-16KB是操作系统在用。然后刚才那个进程被放到了32KB开始，48KB结束，正好16KB。然后其它的位置都是空的。

### 2.10.3 Dynamic (Hardware-based) Relocation

书上讲了一大堆，但实际上简单的要死。上面图里那个例子，其实我们能推测出来，虚拟地址和物理地址是怎么转换的：

$$
物理地址 = 虚拟地址 + 32KB
$$

就这么简单，我们把虚拟地址抠出来，放到物理内存中的某一段。还都是连续的。这样，如果我们想算物理地址，那么只需要一个相对于物理内存起始地址的偏移量就行了。在上面的例子里就是32KB。

这就是第一种策略。它有两个名字：Base and Bounds和Dynamic Relocation。这个策略需要两个特殊的寄存器（硬件）：base register \& bounds (limit) register。

base register里存的就是刚刚的32KB。当进程启动的时候，由操作系统决定这个值是多少。

> [!note] ASIDE: SOFTWARE-BASED RELOCATION
> 以前，妹有这些硬件，那咋办？软件实现呗。这种做法叫做Static Relocation。显然，和我们介绍的基于硬件的做法是相对的。那么，动态在哪儿？静态在哪儿？动态的那种，基础地址是放在寄存器的，操作系统来决定。而静态的，是通过一个叫loader的程序来完成的。
> 
> 比如，有一个指令，是把1000地址的东西放到寄存器里。这个程序被加载到3000的物理地址，那么，loader会重写这个程序，真正执行的时候这个指令的地址就从1000变成了4000。
> 
> 静态重定位有很多问题，最大的问题就是安全。这样进程就可以生成一些不怀好意的地址，来访问其它进程的内存，甚至是操作系统的内存。另一个问题是，这个内存空间后面就没办法再分配到其它的地方了。因为我们把1000重写成了4000，这个值就已经定下来了。

那么bounds register是干嘛的？显然，他都叫limit register了，肯定是为了加一个限制的。在上面的例子中，这个寄存器的值就是16KB。如果虚拟地址的值超过了bounds register中的值，那么程序就会直接挂掉。这样就提供了保护。

> [!info] 
> Bounds Register中存的，实际上就是虚拟地址空间的大小呀！

再次强调，base register和bounds register是**硬件**！一块CPU（的核）有一对儿。人们通常叫这种，能帮忙翻译地址的部分为**Memory Management Unit (MMU)**，后面，MMU还会增加新的成员。

下面是几个翻译的例子：

| Virtual Address | Physical Address      |
| --------------- | --------------------- |
| 0               | 16KB                  |
| 1KB             | 17KB                  |
| 3000            | 19384                 |
| 4400            | Fault (out of bounds) |

### 2.10.4 Hardware Support: A Summary

现在来总结一下，我们都依赖了硬件的什么。首先，在CPU虚拟化中，我们介绍了两种不同的CPU模式。操作系统运行在privileged mode (kernel mode)，对整个机器都有控制权；应用运行在user mode，受控制。通常，有一个bit被存在处理器的status word里面，来表明CPU此时在哪种模式。在一些特定的情况比如系统调用、一些异常、一些中断的时候，CPU会切换模式。

然后就是上面的base register \& bounds register。MMU的一部分。功能我们就不再提了，要注意的是，显然，需要有一些特别设定的指令，用来修改这些寄存器中的值，当不同程序运行的时候才能修改翻译的地址和范围控制。显显然，这些指令也必须是要运行在内核的，普通进程没资格过问。

> [!tip] Free List
> [[#^344dcc|之前]]我们说过，操作系统需要追踪内存的使用情况，才能分配内存。Free List就是这样的一种数据结构，非常简单，就是一个空闲内存的列表，每一个元素是一段空闲内存的地址范围。

最后，就是异常情况。CPU必须在程序试图访问不该访问的内存的时候，抛出一个异常。此时会安排一个Exception Handler去执行，用来终止这个进程和一些其它的操作。

| 硬件需求                     | 注意                                                                                    |
| ------------------------ | ------------------------------------------------------------------------------------- |
| Privileged mode          | 用来阻止用户态的进程执行一些不该执行的指令                                                                 |
| Base / bounds registers  | 用来翻译地址，边界检查                                                                           |
| 翻译地址，边界检查                | emm，这块是文字游戏，上面的寄存器是用来做这些事情的工具，同时这些事情本身也是硬件来完成。所以才都是硬件需求。这里指的其实就是+一下基准地址，检查一下是否超过边界的操作 |
| （一些内核态指令）更新base / bounds | 操作系统必须在程序执行之前设置好寄存器                                                                   |
| （一些内核态指令）注册异常处理          | 当异常发生，操作系统必须告诉硬件该做什么                                                                  |
| 抛出异常的能力                  | 当程序试图访问不改访问的地址时                                                                       |

### 2.10.5 Operating System Issues

刚才我们一直在说硬件的职责，现在来说说操作系统的。硬件目前只负责用来翻译地址，执行指令等，其它的操作还得操作系统来。

首先，当进程启动的时候，OS要给它找个地方。因为我们刚刚假设过每一个地址空间都比物理内存小，大小还是一样的，所以只需要把物理内存看成一个数组，去查一下哪块地方能放下就行。这里就是用上面提到的free list就可以。当然，如果地址空间不一样，会稍微复杂一点，这个后面会提到。

然后程序结束的时候（正常结束或者被中途干掉都算），需要回收所有的内存，退回到free list中。

在上下文切换的时候，OS也需要干活。程序结束（被切走）的时候，需要把base register和bounds register中的值放到内存中，内存中的哪里呢？通常是一个进程独一份的那种地方。比如Process Stucture或者Process Control Block (PCB)。当程序被运行的时候，需要从内存里把这些值load回到寄存器中。

我们需要注意，当程序没在运行（不是运行结束，是被切走）时，OS是可以把这个进程的地址空间给换掉的。做法：

1. 不再调度这个进程（直到切换空间完成）；
2. 把旧地址空间里的东西拷贝到新的地址空间；
3. 更新base register指向新的地址。这里要注意，更新的是内存中存这个值的地方而不是寄存器。

下面是两个图，第一个是系统启动之后OS做的事情，第二个是一个进程启动的时候做的事情：

![[Study Log/os_study/2_virtualization/resources/Pasted image 20250502222434.png]]

![[Study Log/os_study/2_virtualization/resources/Pasted image 20250502222458.png]]

上面的图很好看懂，先是OS做准备工作，初始化trap table、free list等。后面A先启动，然后timer interrupt到了，进行上下文切换，切到了B，然后B干了坏事，然后OS给它干掉了。

可以看到，这里还是符合我们[[Study Log/os_study/2_virtualization/2_3_limited_directed_execution#2.3.3.3 Saving and Restoring Context|LDE]]的思路。在大多数情况，操作系统只需要设置好硬件，然后让程序直接运行在CPU上。只有在==系统调用、时钟中断、干坏事==这些情况，才需要操作系统介入。

> [!comment]- 系统调用、时钟中断、干坏事
> 这里书上用的是"misbehave"这个词，我问了ChatGPT，它也感觉不妥：
> 
> 我：如果程序只是发起了一个系统调用，需要操作系统陷入内核态来完成；或者进行上下文切换，操作系统也要介入执行。这两种情况都是操作系统介入的情况，这种也算程序"misbehave"了么
> 
> ChatGPT：你提到的这个问题非常好，确实有些细节值得澄清。在 OSTEP 这本书中，"misbehave"（“行为不当”）这个词用得有点“口语化”，并不严格等同于“程序错误”或者“出错”。

[[Study Log/os_study/0_ostep_index|Return to Index]]