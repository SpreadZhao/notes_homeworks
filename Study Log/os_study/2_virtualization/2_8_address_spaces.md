---
title:
  - 2.8 Address Spaces
order: "9"
---
[[Study Log/os_study/0_ostep_index|Return to Index]]

## 2.8 Address Spaces

### 2.8.1 Intro

老式的OS，物理内存就是这样子的：

![[Study Log/os_study/2_virtualization/resources/Pasted image 20250212231356.png|200]]

操作系统就是一坨代码（其实就是一个库），从0k起始，一直到64k。然后剩下的就是一个正在运行的进程。老式的OS就是这么简单。

在然后，系统复杂了起来，进程更多了，还有了并发。这个时候，就需要OS有能力从一个进程切换到另一个进程，也就是我们之前介绍的时间片共享、LDE、调度之类的。此时，内存的使用就复杂了。每一个进程都需要一个自己的空间来存数据和代码。

这就需要我们让内存也能实现time sharing。有一种比较简单的方式。运行一个进程一段时间，让它能访问所有的内存，然后停止它，把进程所有的状态（也包括所有的物理内存）保存到磁盘中。加载其他进程的状态，运行一段时间……这样就是一个非常原始的共享内存机制。

显然，这样做太慢了。尤其是内存越来越大。本来内存相对于CPU的寄存器就是累赘，你还用这么个损招。因此，更好的方式就是在切换进程的时候，还让他们留在内存里：

![[Study Log/os_study/2_virtualization/resources/Pasted image 20250214001446.png|200]]

多个进程同时存在于内存，那肯定会产生新问题。很典型的就是安全问题：不能让一个进程随便读写其它进程拥有的内存。

为了更方便用户使用（满足那些傻逼用户的需求），我们设计出了一个对内存的抽象：就是**地址空间**（address space）。对于运行的进程来说，它看到的就不是你的内存条子了，而是这个地址空间。

一个进程的地址空间包含一个运行的进程的所有的能存到内存里的东西。比如：

- 程序的代码；
- 栈空间，用来记录调用栈、本地变量和参数，返回值啥的；
- 堆空间，动态分配的，用户来管理的内存。比如malloc, new分配的内存
- 静态变量等等。。。

我们现在就关注data, stack, heap这三样就行了。接下来解释下面这个图：

![[Study Log/os_study/2_virtualization/resources/Pasted image 20250214004408.png|400]]

- 代码段从0开始，因为代码的大小是已知，并且不会动态变化的，所以就先放它；
- 然后是两个会变的空间，堆和栈。因为都会增长，所以按照图里的方式，让它俩对冲着长。

这么放只是个传统，如果你同时还有多个线程要运行的话，那这种方式就不行了。

当然，现在我们看到的这个0kB,1KB,2KB，是真正的物理内存吗？肯定不是，我们刚说过，我们要让多个进程运行在同一个物理内存中。那么问题就是，怎么做到？答案就是**虚拟内存**（virtual memory）。虚拟内存的作用就是，让进程认为它被加载到了一个特定的地址，同时空间还很大。比如有3个进程，它们都认为自己被加载到了从0开始的，4GB大小的内存中。虽然事实肯定不是这样。

那怎么做到呢？虚拟内存里的地址肯定叫虚拟地址。很简单，我们只要让每一个虚拟地址都能映射到一个实际的物理地址上就行了。

在正式介绍虚拟内存是怎么工作的之前，我们先来具体讨论一下虚拟内存需要实现什么目标：

1. Transparency：就是对进程来说，有这个感觉和没有一样，透明的。具体来说，不能让程序意识到自己的内存是虚拟的。
2. Efficiency：肯定要有效率，在两方面，时间和空间。不能让程序因为虚拟化了内存，就运行变慢了，也不能让程序因为用了虚拟化内存，就占用太多的内存。在时间方面之后我们会介绍TLB这样的硬件的功能。
3. Protection：刚刚提到的安全问题就是。这里也提到了isolation，让每个程序的内存空间都是孤立的岛。

接下来，我们就要正式开始学习内存虚拟化了。

> [!note] 你看到的一切都是虚拟地址：
> 不管你写的什么程序，c的，java的，甚至是汇编的。你拿到的所有地址都是虚拟地址。只有OS（内核中）和硬件知道真正的物理地址在哪里。

[[Study Log/os_study/0_ostep_index|Return to Index]]